{"version":3,"file":"index-82b4c454.js","sources":["../../src/useMediaRecorder.ts","../../src/App.tsx","../../src/utils/isE2E.ts","../../src/main.tsx"],"sourcesContent":["import { ReactElement, useCallback, useEffect, useRef, useState } from 'react';\n\nexport interface ReactMediaRecorderRenderProps {\n  error: string\n  muteAudio: () => void\n  unMuteAudio: () => void\n  startRecording: () => Promise<void>\n  pauseRecording: () => void\n  resumeRecording: () => void\n  stopRecording: () => void\n  mediaBlobUrl: undefined | string\n  status: StatusMessages\n  isAudioMuted: boolean\n  previewStream: MediaStream | null\n  previewAudioStream: MediaStream | null\n  clearBlobUrl: () => void\n}\n\nexport interface ReactMediaRecorderHookProps {\n  audio?: boolean | MediaTrackConstraints\n  video?: boolean | MediaTrackConstraints\n  screen?: boolean\n  onStop?: (blobUrl: string, blob: Blob) => void\n  onStart?: () => void\n  blobPropertyBag?: BlobPropertyBag\n  mediaRecorderOptions?: MediaRecorderOptions | undefined\n  customMediaStream?: MediaStream | null\n  stopStreamsOnStop?: boolean\n  askPermissionOnMount?: boolean\n}\nexport type ReactMediaRecorderProps = ReactMediaRecorderHookProps & {\n  render: (props: ReactMediaRecorderRenderProps) => ReactElement\n};\n\nexport type StatusMessages =\n    | 'media_aborted'\n    | 'permission_denied'\n    | 'no_specified_media_found'\n    | 'media_in_use'\n    | 'invalid_media_constraints'\n    | 'no_constraints'\n    | 'recorder_error'\n    | 'idle'\n    | 'acquiring_media'\n    | 'delayed_start'\n    | 'recording'\n    | 'stopping'\n    | 'stopped'\n    | 'paused';\n\nexport enum RecorderErrors {\n  AbortError = 'media_aborted',\n  NotAllowedError = 'permission_denied',\n  NotFoundError = 'no_specified_media_found',\n  NotReadableError = 'media_in_use',\n  OverconstrainedError = 'invalid_media_constraints',\n  TypeError = 'no_constraints',\n  NONE = '',\n  NO_RECORDER = 'recorder_error',\n}\n\nexport function useReactMediaRecorder({\n  audio = true,\n  video = false,\n  onStop = () => null,\n  onStart = () => null,\n  blobPropertyBag,\n  screen = false,\n  mediaRecorderOptions = undefined,\n  customMediaStream = null,\n  stopStreamsOnStop = true,\n  askPermissionOnMount = false\n}: ReactMediaRecorderHookProps): ReactMediaRecorderRenderProps {\n  const mediaRecorder = useRef<MediaRecorder | null>(null);\n  const mediaChunks = useRef<Blob[]>([]);\n  const mediaStream = useRef<MediaStream | null>(null);\n  const [status, setStatus] = useState<StatusMessages>('idle');\n  const [isAudioMuted, setIsAudioMuted] = useState<boolean>(false);\n  const [mediaBlobUrl, setMediaBlobUrl] = useState<string | undefined>(undefined);\n  const [error, setError] = useState<keyof typeof RecorderErrors>('NONE');\n\n  const getMediaStream = useCallback(async () => {\n    setStatus('acquiring_media');\n    const requiredMedia: MediaStreamConstraints = {\n      audio: typeof audio === 'boolean' ? !!audio : audio,\n      video: typeof video === 'boolean' ? !!video : video\n    };\n    try {\n      if (customMediaStream) {\n        mediaStream.current = customMediaStream;\n      } else if (screen) {\n        const stream = (await window.navigator.mediaDevices.getDisplayMedia({\n          video: video || true\n        }));\n        stream.getVideoTracks()[0].addEventListener('ended', () => {\n          stopRecording();\n        });\n        if (audio) {\n          const audioStream = await window.navigator.mediaDevices.getUserMedia({\n            audio\n          });\n\n          audioStream\n            .getAudioTracks()\n            .forEach((audioTrack) => stream.addTrack(audioTrack));\n        }\n        mediaStream.current = stream;\n      } else {\n        const stream = await window.navigator.mediaDevices.getUserMedia(\n          requiredMedia\n        );\n        mediaStream.current = stream;\n      }\n      setStatus('idle');\n    } catch (error: any) {\n      setError(error.name);\n      setStatus('idle');\n    }\n  }, [audio, video, screen]);\n\n  useEffect(() => {\n    if (!window.MediaRecorder) {\n      throw new Error('Unsupported Browser');\n    }\n\n    if (screen) {\n      if (!window.navigator.mediaDevices.getDisplayMedia) {\n        throw new Error('This browser doesn\\'t support screen capturing');\n      }\n    }\n\n    const checkConstraints = (mediaType: MediaTrackConstraints) => {\n      const supportedMediaConstraints =\n                navigator.mediaDevices.getSupportedConstraints();\n      const unSupportedConstraints = Object.keys(mediaType).filter(\n        (constraint) =>\n          !(supportedMediaConstraints as { [key: string]: any })[constraint]\n      );\n\n      if (unSupportedConstraints.length > 0) {\n        console.error(\n                    `The constraints ${unSupportedConstraints.join(\n                        ','\n                    )} doesn't support on this browser. Please check your ReactMediaRecorder component.`\n        );\n      }\n    };\n\n    if (typeof audio === 'object') {\n      checkConstraints(audio);\n    }\n    if (typeof video === 'object') {\n      checkConstraints(video);\n    }\n\n    if (mediaRecorderOptions?.mimeType) {\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\n        console.error(\n          'The specified MIME type you supplied for MediaRecorder doesn\\'t support this browser'\n        );\n      }\n    }\n\n    if (!mediaStream.current && askPermissionOnMount) {\n      getMediaStream();\n    }\n\n    return () => {\n      if (mediaStream.current) {\n        const tracks = mediaStream.current.getTracks();\n        tracks.forEach((track) => track.clone().stop());\n      }\n    };\n  }, [\n    audio,\n    screen,\n    video,\n    getMediaStream,\n    mediaRecorderOptions,\n    askPermissionOnMount\n  ]);\n\n  // Media Recorder Handlers\n\n  const startRecording = async () => {\n    setError('NONE');\n    if (!mediaStream.current) {\n      await getMediaStream();\n    }\n    if (mediaStream.current) {\n      const isStreamEnded = mediaStream.current\n        .getTracks()\n        .some((track) => track.readyState === 'ended');\n      if (isStreamEnded) {\n        await getMediaStream();\n      }\n\n      // User blocked the permissions (getMediaStream errored out)\n      if (!mediaStream.current.active) {\n        return;\n      }\n      mediaRecorder.current = new MediaRecorder(\n        mediaStream.current, mediaRecorderOptions ?? undefined\n      );\n      mediaRecorder.current.ondataavailable = onRecordingActive;\n      mediaRecorder.current.onstop = onRecordingStop;\n      mediaRecorder.current.onstart = onRecordingStart;\n      mediaRecorder.current.onerror = () => {\n        setError('NO_RECORDER');\n        setStatus('idle');\n      };\n      mediaRecorder.current.start();\n      setStatus('recording');\n    }\n  };\n\n  const onRecordingActive = ({ data }: BlobEvent) => {\n    mediaChunks.current.push(data);\n  };\n\n  const onRecordingStart = () => {\n    onStart();\n  };\n\n  const onRecordingStop = () => {\n    const [chunk] = mediaChunks.current;\n    const blobProperty: BlobPropertyBag = Object.assign(\n      { type: chunk.type },\n      blobPropertyBag ?? (video ? { type: 'video/mp4' } : { type: 'audio/ogg; codecs=opus' })\n    );\n    const blob = new Blob(mediaChunks.current, blobProperty);\n    const url = URL.createObjectURL(blob);\n    setStatus('stopped');\n    setMediaBlobUrl(url);\n    onStop(url, blob);\n  };\n\n  const muteAudio = (mute: boolean) => {\n    setIsAudioMuted(mute);\n    if (mediaStream.current) {\n      mediaStream.current\n        .getAudioTracks()\n        .forEach((audioTrack) => (audioTrack.enabled = !mute));\n    }\n  };\n\n  const pauseRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === 'recording') {\n      setStatus('paused');\n      mediaRecorder.current.pause();\n    }\n  };\n  const resumeRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === 'paused') {\n      setStatus('recording');\n      mediaRecorder.current.resume();\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorder.current) {\n      if (mediaRecorder.current.state !== 'inactive') {\n        setStatus('stopping');\n        mediaRecorder.current.stop();\n        if (stopStreamsOnStop) {\n          mediaStream?.current?.getTracks().forEach((track) => track.stop());\n        }\n        mediaChunks.current = [];\n      }\n    }\n  };\n\n  return {\n    error: RecorderErrors[error],\n    muteAudio: () => muteAudio(true),\n    unMuteAudio: () => muteAudio(false),\n    startRecording,\n    pauseRecording,\n    resumeRecording,\n    stopRecording,\n    mediaBlobUrl,\n    status,\n    isAudioMuted,\n    previewStream: mediaStream.current\n      ? new MediaStream(mediaStream.current.getVideoTracks())\n      : null,\n    previewAudioStream: mediaStream.current\n      ? new MediaStream(mediaStream.current.getAudioTracks())\n      : null,\n    clearBlobUrl: () => {\n      if (mediaBlobUrl) {\n        URL.revokeObjectURL(mediaBlobUrl);\n      }\n      setMediaBlobUrl(undefined);\n      setStatus('idle');\n    }\n  };\n}\n\nexport const ReactMediaRecorder = (props: ReactMediaRecorderProps) =>\n  props.render(useReactMediaRecorder(props));\n","import { useEffect, useRef, useState } from 'react';\nimport './App.css';\nimport YouTube from 'react-youtube';\nimport { useReactMediaRecorder } from './useMediaRecorder';\nimport createPersistedState from 'use-persisted-state';\n\nconst useVideoId = createPersistedState<string>('video-id');\nconst usePreviousVideos = createPersistedState<Array<{ id: string, title: string }>>('previous-videos');\nconst useLag = createPersistedState<number>('lag-id');\n\nfunction App() {\n  const [video, setVideo] = useVideoId('jcL38GYrk-I'); // DBeHQfvqO6k\n  const [playbackStartedAt, setPlaybackStartedAt] = useState(0);\n  const [recordOffset, setRecordOffset] = useState(0);\n  const [recordStartedAt, setRecordStartedAt] = useState(0);\n  const recorder = useReactMediaRecorder({\n    audio: {\n      echoCancellation: false,\n      noiseSuppression: false,\n      autoGainControl: false\n    },\n    video: false,\n    askPermissionOnMount: true,\n    onStart: () => setRecordStartedAt(performance.now())\n  });\n  const [isRecording, setIsRecording] = useState(false);\n  const player = useRef<YouTube | null>(null);\n  const audio = useRef<HTMLAudioElement>(null);\n  const [lag, setLag] = useLag(-56);\n\n  const timeoutRef = useRef<number>();\n  const pauseAudio = () => {\n    audio.current?.pause();\n    clearTimeout(timeoutRef.current);\n  };\n\n  const playAt = (seconds: number) => {\n    clearTimeout(timeoutRef.current);\n    const newTime = seconds + (recordStartedAt - playbackStartedAt) / 1000 + lag / 1000 - recordOffset;\n\n    if (newTime < 0) {\n      audio.current && (audio.current.currentTime = 0);\n      timeoutRef.current = setTimeout(() => audio.current?.play(), newTime * -1000 * (1 / (audio.current?.playbackRate ?? 1)));\n    } else {\n      audio.current && (audio.current.currentTime = newTime);\n      const start = performance.now();\n      audio.current?.play().then(() => console.log('playback lag', performance.now() - start));\n    }\n  };\n  const startRecording = async () => {\n    await player.current?.getInternalPlayer().pauseVideo();\n    setTimeout(async () => {\n      setIsRecording(true);\n      const time = await player.current?.internalPlayer.getCurrentTime();\n      setRecordOffset(time);\n      player.current?.internalPlayer.playVideo();\n    }, 100);\n  };\n\n  const restartPlayer = () => {\n    player.current?.internalPlayer.seekTo(0);\n    player.current?.internalPlayer.playVideo();\n  };\n\n  useEffect(() => {\n    const audioElem = audio.current;\n    if (audioElem && !audioElem.paused && !audioElem.ended && !!audioElem.currentTime) {\n      player.current?.getInternalPlayer().getCurrentTime().then((time: number) => {\n        audioElem.currentTime = time + (recordStartedAt - playbackStartedAt) / 1000 + lag / 1000 - recordOffset;\n      });\n    }\n  }, [lag, audio]);\n\n  const stopRecording = () => {\n    setIsRecording(false);\n    recorder.stopRecording();\n  };\n\n  const [previousVideos, setPreviousVideos] = usePreviousVideos([]);\n\n  return (\n        <div className=\"App\">\n           <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>{\n                previousVideos.map(({ id, title }) => (\n                    <button onClick={() => setVideo(id)} disabled={id === video} key={id}>{title}</button>\n                ))\n            }\n           </div>\n            <input value={video} onChange={e => setVideo(e.target.value)}/>\n            <YouTube\n                ref={player}\n                videoId={video}\n                id=\"youtube-player\"\n                onPlaybackRateChange={async () => {\n                  const currentRate = await player.current?.getInternalPlayer().getPlaybackRate();\n                  audio.current && (audio.current.playbackRate = currentRate);\n                  playAt(await player.current?.getInternalPlayer().getCurrentTime());\n                }}\n                onPlay={() => {\n                  if (!isRecording) {\n                    player.current?.internalPlayer.getCurrentTime().then(playAt);\n                  } else {\n                    setPlaybackStartedAt(performance.now());\n                    recorder.startRecording();\n                  }\n\n                  if (!previousVideos.find(({ id }) => video === id)) {\n                    const title = document.getElementById('youtube-player')?.title ?? video;\n                    setPreviousVideos(current => [{ id: video, title }, ...current].slice(0, 10));\n                  }\n                }}\n                     onEnd={isRecording ? stopRecording : pauseAudio}\n                     onPause={isRecording ? stopRecording : pauseAudio}\n\n            />\n            <audio src={recorder.mediaBlobUrl} controls ref={audio}/>\n            {!isRecording && <button onClick={startRecording}>record</button>}\n            {isRecording && <button onClick={stopRecording}>stop recording</button>}\n            <button onClick={restartPlayer}>replay</button>\n          <div>\n            <input type=\"number\" step={4} value={lag} onChange={e => setLag(+e.target.value)}/><br />\n            <input type={'range'} min={-250} max={250} value={lag} onChange={e => setLag(+e.target.value)} style={{ width: 640 }} />\n          </div>\n        </div>\n  );\n}\n\nexport default App;\n","export default function isE2E() {\n  // @ts-expect-error\n  return window.isE2ETests || window.location.search.includes('e2e-test');\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nimport './index.css';\nimport * as Sentry from '@sentry/react';\nimport isDev from 'utils/isDev';\nimport isE2E from 'utils/isE2E';\n\nif (import.meta.env.VITE_APP_SENTRY_DSN_URL) {\n  Sentry.init({\n    dsn: import.meta.env.VITE_APP_SENTRY_DSN_URL,\n\n    // Set tracesSampleRate to 1.0 to capture 100%\n    // of transactions for performance monitoring.\n    // We recommend adjusting this value in production\n    tracesSampleRate: 1.0,\n    environment: isDev() ? 'development' : isE2E() ? 'e2e' : 'production'\n  });\n}\n\nReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n"],"names":["RecorderErrors","useReactMediaRecorder","audio","video","onStop","onStart","blobPropertyBag","screen","mediaRecorderOptions","customMediaStream","stopStreamsOnStop","askPermissionOnMount","mediaRecorder","useRef","mediaChunks","mediaStream","status","setStatus","useState","isAudioMuted","setIsAudioMuted","mediaBlobUrl","setMediaBlobUrl","error","setError","getMediaStream","useCallback","requiredMedia","stream","stopRecording","audioTrack","useEffect","checkConstraints","mediaType","supportedMediaConstraints","unSupportedConstraints","constraint","track","startRecording","onRecordingActive","onRecordingStop","onRecordingStart","data","chunk","blobProperty","blob","url","muteAudio","mute","pauseRecording","resumeRecording","_a","useVideoId","createPersistedState","usePreviousVideos","useLag","App","setVideo","playbackStartedAt","setPlaybackStartedAt","recordOffset","setRecordOffset","recordStartedAt","setRecordStartedAt","recorder","isRecording","setIsRecording","player","lag","setLag","timeoutRef","pauseAudio","playAt","seconds","newTime","start","_b","time","restartPlayer","audioElem","previousVideos","setPreviousVideos","jsxs","jsx","id","title","e","YouTube","currentRate","current","isE2E","Sentry.init","ReactDOM","React"],"mappings":"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"}